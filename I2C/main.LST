C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE MOD517 DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************************************************************
   2          h e i n r i c h -h e r t z -b e r u f s k o l l e g  d e r  s t a d t  b o n n
   3          Autor:      Friedjof Noweck
   4          Klasse:     IH119
   5          Datum:      2022-03-16
   6          Datei:      
   7          Einsatz:    
   8          Beschreibung:
   9          Funktionen:   
  10          ******************************************************************************
  11          Aenderungen:
  12          2022-03-23 Add ms and year to LCD
  13          
  14          *****************************************************************************/
  15          /******************* Text im Quelltext einbinden *********************/
  16          #include "REG517A.h"
  17          #include "I2C_api.h"
  18          #include "lcd_api.h"
  19          #include "RTC_api.h"
  20          #include <string.h>
  21          /*************************** Konstanten ******************************/
  22          volatile unsigned char xdata i2c_reg _at_ 0xffa0;
  23          volatile unsigned char xdata i2c_s1 _at_ 0xffa1;
  24          
  25          unsigned char xdata xmem[0x0feff] _at_ 0;
  26          
  27          volatile char xdata cmd _at_ 0xFF80;
  28          volatile char xdata chr _at_ 0xFF82;
  29          
  30          /*********************** globale Variablen ***************************/
  31          unsigned char rtc_buf[16];
  32          unsigned char RTC_ADDR = 0x0a0;
  33          char Text[] = "Mo, 11.11.11,\n11:11:11:00 Uhr";
  34          
  35          /************************** Prototypen *******************************/
  36          void init_I2C();
  37          void init_LCD();
  38          void Clear_LCD();
  39          void showChar(char value);  
  40          void showText(char* value);
  41          void i2c_xmit(unsigned char slave_addr, unsigned char length,unsigned char * buffer);
  42          unsigned char i2c_rcv(unsigned char slave_addr, unsigned char word_addr,unsigned char length, unsigned cha
             -r * buffer);
  43          void rtc_settime(unsigned char dt, unsigned char mt, unsigned char hh, unsigned char mm, unsigned char ss)
             -;
  44          void rtc_readtime(unsigned char *dt, unsigned char *mt, unsigned char *hh, unsigned char *mm, unsigned cha
             -r *ss, unsigned char *ms);
  45          void Wochentag (unsigned char t);
  46          /************************ Hauptprogramm ******************************/
  47          
  48          void main()
  49          {
  50   1        unsigned char ss = 0x00;
  51   1        unsigned char mm = 0x00;
  52   1        unsigned char hh = 0x00;
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 2   

  53   1        unsigned char dt = 0x00;
  54   1        unsigned char mt = 0x00;
  55   1        unsigned char ms = 0x00;
  56   1        unsigned char yy = 0x00;
  57   1        unsigned char lastYY = 0x00;
  58   1        unsigned char currentYY = 0x00;
  59   1        unsigned char jahreSeitStart = 0x00;
  60   1        
  61   1        unsigned char aktuellesYY;
  62   1        unsigned char YYSeitLetztemSchaltjahr;
  63   1        
  64   1        int index;
  65   1        
  66   1        Clear_LCD();
  67   1        init_LCD();
  68   1        init_I2C();
  69   1        
  70   1        // 2020-12-31 23:59:55,00
  71   1        aktuellesYY = 22;
  72   1        YYSeitLetztemSchaltjahr = 2;
  73   1        rtc_settime((YYSeitLetztemSchaltjahr << 0x06) | 0x31, 0x12, 0x23, 0x59, 0x55);
  74   1        
  75   1        // 2023-12-31 23:59:55,00
  76   1        aktuellesYY = 23;
  77   1        YYSeitLetztemSchaltjahr = 3;
  78   1        rtc_settime((YYSeitLetztemSchaltjahr << 0x06) | 0x31, 0x12, 0x23, 0x59, 0x55);
  79   1        
  80   1        lastYY = YYSeitLetztemSchaltjahr;
  81   1      
  82   1        while(1)
  83   1        {
  84   2          rtc_readtime(&dt, &mt, &hh, &mm, &ss, &ms);
  85   2          
  86   2          // Millisekunden
  87   2          Text[24] = (ms & 0x0F)+ 48;
  88   2          Text[23] = ((ms & 0xF0) >> 0x04) + 48;
  89   2          
  90   2          // Sekunden
  91   2          Text[21] = (ss & 0x0F) + 48;
  92   2          Text[20] = ((ss & 0xF0) >> 0x04) + 48;
  93   2          
  94   2          // Minuten
  95   2          Text[18] = (mm & 0x0F) + 48;
  96   2          Text[17] = ((mm & 0xF0) >> 0x04) + 48;
  97   2          
  98   2          // Stunden
  99   2          Text[15] = (hh & 0x0F) + 48;
 100   2          Text[14] = ((hh & 0xF0) >> 0x04) + 48;
 101   2          
 102   2          // Tag
 103   2          Text[5] = (dt & 0x0F) + 48;
 104   2          Text[4] = ((dt & 0x30) >> 0x04) + 48;
 105   2      
 106   2          // Wochentag
 107   2          Wochentag((mt & 0xE0) >> 0x05);
 108   2          
 109   2          // Monat
 110   2          Text[8] = (mt & 0x0F) + 48;
 111   2          Text[7] = ((mt & 0x10) >> 0x04) + 48;
 112   2          
 113   2          // Jahr
 114   2          currentYY = ((dt & 0xD0) >> 0x06);
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 3   

 115   2          
 116   2          if (currentYY ^ lastYY)
 117   2          {
 118   3            lastYY = currentYY;
 119   3            jahreSeitStart++;
 120   3          }
 121   2          
 122   2          yy = jahreSeitStart + aktuellesYY;
 123   2          for (index = 0x00; index < 2; index++)
 124   2          {
 125   3            Text[11 - index] = (yy % 10) + 0x30;
 126   3            yy /= 10;
 127   3          }
 128   2          
 129   2          showText(Text);
 130   2        }
 131   1      }
 132          void Wochentag (unsigned char t)
 133          {
 134   1        switch(t)
 135   1        {
 136   2          case 0x00: 
 137   2                  Text[0] = 'M';
 138   2                  Text[1] = 'o';
 139   2            break; 
 140   2          case 0x01: 
 141   2                  Text[0] = 'D';
 142   2                  Text[1] = 'i';
 143   2            break;
 144   2          case 0x02: 
 145   2                 Text[0] = 'M';
 146   2                 Text[1] = 'i';
 147   2            break;
 148   2          case 0x03: 
 149   2                 Text[0] = 'D';
 150   2                 Text[1] = 'o';
 151   2            break;
 152   2          case 0x04: 
 153   2                 Text[0] = 'F';
 154   2                 Text[1] = 'r';
 155   2            break;
 156   2          case 0x05: 
 157   2                 Text[0] = 'S';
 158   2                 Text[1] = 'a';
 159   2            break;
 160   2          case 0x06:
 161   2                Text[0] = 'S';
 162   2                Text[1] = 'o';
 163   2            break;
 164   2          default:
 165   2            break;
 166   2        }
 167   1      }
 168          void init_LCD()
 169          {
 170   1        int index1;
 171   1      
 172   1        //Funktion definieren: 2  zeilig, 5x7 Dots, 8 Bit
 173   1        cmd = 0x38; 
 174   1        for(index1=0;index1<7;index1++);//ca. 50ys warten (mind. 39)
 175   1        
 176   1        //Display An, Cursor Aus, Blinken aus
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 4   

 177   1        cmd = 0x0C;
 178   1        for(index1=0;index1<7;index1++);//ca. 50ys warten
 179   1        
 180   1        Clear_LCD();
 181   1        
 182   1        //Entry Mode: autom Increment ohne Shift
 183   1        cmd = 0x06;
 184   1        for(index1=0;index1<7;index1++);//ca. 50ys warten
 185   1      }
 186          void Clear_LCD()
 187          {
 188   1        int index1;
 189   1          cmd = 0x02;
 190   1          cmd = 0x01;
 191   1         for(index1=0;index1<470;index1++){}//ca. 2ms warten (mind. 1.57)
 192   1      }
 193          void showChar(char value)
 194          {
 195   1        int index1;
 196   1        if(value == 0)
 197   1        {
 198   2          return;
 199   2        }
 200   1        if(value != '\n')
 201   1        {
 202   2          chr = value;
 203   2        }
 204   1        else
 205   1        {
 206   2          cmd = 0xC0; //->  Adresse auf die zweite Zeile setzen: 1 ( 1 0 0   0 0 0 0) 
 207   2                //-> DRAM Adresse 0x40!
 208   2        }
 209   1        for(index1=0;index1<10;index1++);//ca. 50ys warten
 210   1        }
 211          void showText(char* value)
 212          {
 213   1        int laenge = strlen(value); //Textlänge wird bestimmt
 214   1        int index = 0;
 215   1        int index2 = 0;
 216   1        int index3 = 0;
 217   1        Clear_LCD();
 218   1      
 219   1        for(index = 0;index < laenge;index++)
 220   1        {
 221   2        //Erste Zeile
 222   2          if(index3 < 16 || (index3 > 16 && index3 < 32))
 223   2          {
 224   3          if(value[index] == '\n' && index3 < 16)
 225   3          {
 226   4          index3 = 16;
 227   4          }
 228   3          else if(value[index] == '\n' && index3 > 16)
 229   3          {
 230   4          index3 = 32;
 231   4        }
 232   3        showChar(value[index]);
 233   3      
 234   3        index3++;
 235   3        }//Zweite Zeile
 236   2        else if(index3==16)
 237   2        {
 238   3        showChar('\n');
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 5   

 239   3        showChar(value[index]);
 240   3        index3++;
 241   3        }
 242   2        else if(index3 >= 32)
 243   2        {
 244   3        Clear_LCD();
 245   3        index3 = -1;
 246   3        }
 247   2        }
 248   1        for(index=0;index<370;index++){}
 249   1      }
 250          void init_I2C()
 251          {
 252   1        i2c_s1 = 0x80;  // Select internal register S0
 253   1        i2c_reg = 0x55; // S0 = 0x55 (set effective own address to AAh)
 254   1        i2c_s1 = 0x0a0; // Select internal register S2
 255   1        i2c_reg = 0x1c; // System Clock is 12 MHz; SCL = 90 kHz
 256   1        i2c_s1 = 0x0c1; // Enable interface and select S0
 257   1      }
 258          
 259          void i2c_xmit(unsigned char slave_addr, unsigned char length,unsigned char * buffer)
 260          {
 261   1        unsigned char i;
 262   1        //Waiting for Bus free
 263   1        while ((i2c_s1 & 1) ==0) {};
 264   1        i2c_s1 = 0x0c5;         // START condition
 265   1      
 266   1        i2c_reg = slave_addr;   // Set slave address
 267   1      
 268   1        for (i=0; i<length; i++)
 269   1        {
 270   2          //wait for Client
 271   2          while ((i2c_s1 & 0x80) !=0);        // poll for ready
 272   2          if ((i2c_s1 & 0x08) !=0) 
 273   2          break;                // if ack, leave loop
 274   2          //send Byte
 275   2          i2c_reg = buffer[i];                // send data
 276   2        }
 277   1        while ((i2c_s1 & 0x80) !=0);          // poll for ready
 278   1       i2c_s1 = 0x0c3; // sTOP
 279   1      }
 280          
 281          unsigned char i2c_rcv(unsigned char slave_addr, unsigned char word_addr,unsigned char length, unsigned cha
             -r * buffer)
 282          {
 283   1        unsigned char i;
 284   1        unsigned char error = 0;
 285   1        while ((i2c_s1 & 1) ==0) {}; // wait for free bus
 286   1      
 287   1        i2c_s1 = 0x0c5;  //START Condition
 288   1        i2c_reg = slave_addr;
 289   1        //wait for Slave
 290   1          while ((i2c_s1 & 0x80) !=0);
 291   1      
 292   1        if ((i2c_s1 & 0x08) !=0) 
 293   1        { // no slave ACK
 294   2            i2c_s1 = 0x0c3; // sTOP
 295   2            return 1;
 296   2        }
 297   1        else
 298   1        {}
 299   1          //Registeradresse
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 6   

 300   1          i2c_reg = word_addr;
 301   1      
 302   1        //Wait for Slave
 303   1          while ((i2c_s1 & 0x80) !=0);
 304   1      
 305   1        if ((i2c_s1 & 0x08) !=0) 
 306   1        { // no slave ACK
 307   2            i2c_s1 = 0x0c3; // sTOP
 308   2            return 1;
 309   2        }
 310   1        else
 311   1        {}
 312   1      
 313   1        i2c_s1 = 0x0c5;  // START condition
 314   1       
 315   1        i2c_reg = slave_addr+1; // Set slave address
 316   1        for (i=0; i<length; i++)
 317   1        {
 318   2          //wait for Slave
 319   2          while ((i2c_s1 & 0x80) !=0);  // poll for ready
 320   2      
 321   2          if ((i2c_s1 & 0x08) !=0) { // no slave ACK
 322   3            error = 1;
 323   3            break;
 324   3          }
 325   2        else
 326   2        {}
 327   2      
 328   2        //Byte lesen
 329   2          buffer[i] = i2c_reg;
 330   2        }
 331   1        if (error == 0)
 332   1        {
 333   2          i2c_s1 = 0x040; // prepare NACK
 334   2          buffer[i] = i2c_reg; // read final byte
 335   2          while ((i2c_s1 & 0x80) !=0);
 336   2        }
 337   1      
 338   1        i2c_s1 = 0x0c3; // sTOP
 339   1      
 340   1        return error;
 341   1      }
 342          
 343          void rtc_settime(unsigned char dt, unsigned char mt, unsigned char hh, unsigned char mm, unsigned char ss)
 344          {
 345   1        unsigned char buffer[6];
 346   1        
 347   1        buffer[0] = 2;
 348   1        buffer[1] = ss;
 349   1        buffer[2] = mm;
 350   1        buffer[3] = hh;
 351   1        buffer[4] = dt;
 352   1        buffer[5] = mt;
 353   1        
 354   1        i2c_xmit(RTC_ADDR,6,buffer);
 355   1      }
 356          
 357          void rtc_readtime(unsigned char *dt, unsigned char *mt, unsigned char *hh, unsigned char *mm, unsigned cha
             -r *ss, unsigned char *ms)
 358          {
 359   1        unsigned char buffer[8] = {0, 1, 2, 3, 4, 5, 6, 7};
 360   1      
C51 COMPILER V9.60.0.0   MAIN                                                              03/23/2022 12:24:26 PAGE 7   

 361   1        i2c_rcv(RTC_ADDR,1,6,buffer);
 362   1      
 363   1        *ms = buffer[1];
 364   1        *ss = buffer[2];
 365   1        *mm = buffer[3];
 366   1        *hh = buffer[4];
 367   1        *dt = buffer[5];
 368   1        *mt = buffer[6];
 369   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1203    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47      69
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
