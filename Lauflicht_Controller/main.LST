C51 COMPILER V9.60.0.0   MAIN                                                              11/23/2021 16:42:24 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: Z:\home\friedjof\Applications\uVision\C51\BIN\C51.exe main.c ROM(SMALL) OPTIMIZE(8,SPEED) BROWSE DE
                    -BUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************************************************************
   2          h e i n r i c h -h e r t z -b e r u f s k o l l e g  d e r  s t a d t  b o n n
   3          Autor:      Friedjof Noweck
   4          Klasse:     IH119
   5          Datum:      
   6          Datei:      
   7          Einsatz:    
   8          Beschreibung: 
   9          Funktionen:   
  10          ******************************************************************************
  11          Aenderungen:
  12          2021-11-08 - Anlegen dieses Projektes
  13          2021-11-23 - Hinzufügen der Funktionalitäten "umdrehen" und "stoppen"
  14          
  15          *****************************************************************************/
  16          /******************* Text im Quelltext einbinden *********************/
  17          #include "REG517A.h"
  18          
  19          /*************************** Konstanten ******************************/
  20          
  21          
  22          /*********************** globale Variablen ***************************/
  23          
  24          
  25          /************************** Prototypen *******************************/
  26          void readButton(int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus);
  27          void LEDRunner(int* max_bit_nr, int* direction, int* bit_index, int* port);
  28          void flipDirection(int* direction, int* bit_index, int* max_bit_nr);
  29          void delay(int ms);
  30          void port_controller(int port, int *port_nr);
  31          int potenzieren(int basis, int potenz);
  32          
  33          /************************ Hauptprogramm ******************************/
  34          
  35          void main()
  36          {
  37   1        const int max_bit_nr = 15;
  38   1        int direction = 1;
  39   1        int bit_index = 0;
  40   1        int port = 1;
  41   1        char stop = 0x00;
  42   1        
  43   1        char buttonStatus = 0x00;
  44   1        
  45   1        // Set ports to zero
  46   1        P1 = 0x00;
  47   1        P4 = 0x00;
  48   1        
  49   1        while (1)
  50   1        {
  51   2          readButton(&direction, &stop, &bit_index, &max_bit_nr, &buttonStatus);
  52   2          
  53   2          if (stop == 0x00)
  54   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              11/23/2021 16:42:24 PAGE 2   

  55   3            LEDRunner(&max_bit_nr, &direction, &bit_index, &port);
  56   3          }
  57   2          else
  58   2          { }
  59   2        }
  60   1      }
  61          
  62          void readButton(int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus)
  63          {
  64   1        char button2 = *buttonStatus & 0x02;
  65   1        // Port 5 wird abgefragt
  66   1        if ((P5 & 0x01) == 0x00 && (*buttonStatus & 0x01) == 0x00)
  67   1        {
  68   2          *buttonStatus = *buttonStatus | 0x01;
  69   2          
  70   2          flipDirection(direction, bit_index, max_bit_nr);
  71   2        }
  72   1        else if ((P5 & 0x01) == 0x01 && (*buttonStatus & 0x01) == 0x01)
  73   1        {
  74   2          *buttonStatus = *buttonStatus & 0x0FE;
  75   2        }
  76   1        // Port 6 wird abgefragt
  77   1        if ((P6 & 0x01) == 0x00 &&  button2 == 0x00)
  78   1        {
  79   2          *buttonStatus = *buttonStatus | 0x02;
  80   2          
  81   2          if (*stop == 1)
  82   2          {
  83   3            *stop = 0x00;
  84   3          }
  85   2          else
  86   2          {
  87   3            *stop = 0x01;
  88   3          }
  89   2        }
  90   1        else if ((P6 & 0x01) == 0x01 && button2 == 0x02)
  91   1        {
  92   2          *buttonStatus = *buttonStatus & 0x0FD;
  93   2        }
  94   1        delay(50);
  95   1      }
  96          
  97          void flipDirection(int* direction, int* bit_index, int* max_bit_nr)
  98          {
  99   1        if (*direction == 0x01)
 100   1        {
 101   2          *direction = 0x00;
 102   2        }
 103   1        else
 104   1        {
 105   2          *direction = 0x01;
 106   2        }
 107   1        
 108   1        *bit_index = (*max_bit_nr - *bit_index) + 1;
 109   1      }
 110          
 111          void LEDRunner(int* max_bit_nr, int* direction, int* bit_index, int* port)
 112          {
 113   1        int index = 0;
 114   1        
 115   1        if (*bit_index <= *max_bit_nr)
 116   1        {
C51 COMPILER V9.60.0.0   MAIN                                                              11/23/2021 16:42:24 PAGE 3   

 117   2          if (*direction == 1)
 118   2          {
 119   3            if (*bit_index <= 7)
 120   3            {
 121   4              *port = 1;
 122   4              index = *bit_index;
 123   4            }
 124   3            else
 125   3            {
 126   4              *port = 4;
 127   4              index = 0x07 - (*max_bit_nr - *bit_index);
 128   4            }
 129   3          }
 130   2          else
 131   2          {
 132   3            if (*bit_index <= 7)
 133   3            {
 134   4              *port = 4;
 135   4              index = 0x07 - *bit_index;
 136   4            }
 137   3            else
 138   3            {
 139   4              *port = 1;
 140   4              index = *bit_index - *max_bit_nr;
 141   4            }
 142   3          }
 143   2          // switch LED's
 144   2          port_controller(index, port);
 145   2          
 146   2          // add one to the Bit Index
 147   2          *bit_index += 1;
 148   2        }
 149   1        else
 150   1        {
 151   2          // reset Bit Index
 152   2          *bit_index = 1;
 153   2          
 154   2          if (*direction == 1)
 155   2          {
 156   3            *direction = 0x00;
 157   3          }
 158   2          else
 159   2          {
 160   3            *direction = 0x01;
 161   3          }
 162   2        }
 163   1      }
 164          
 165          
 166          void port_controller(int port, int *port_nr)
 167          {
 168   1        char portOn = 0x00;
 169   1      
 170   1        // turn all bits off
 171   1        P1 = P1 & 0x00;
 172   1        P4 = P4 & 0x00;
 173   1      
 174   1        if (*port_nr == 1)
 175   1        {
 176   2          // turn bit on
 177   2          portOn = potenzieren(2, port);
 178   2          P1 = P1 | portOn;
C51 COMPILER V9.60.0.0   MAIN                                                              11/23/2021 16:42:24 PAGE 4   

 179   2        }
 180   1        else if (*port_nr == 4)
 181   1        {
 182   2          // turn bit on
 183   2          portOn = potenzieren(2, port);
 184   2          P4 = P4 | portOn;
 185   2        }
 186   1        else
 187   1        { }
 188   1      }
 189          
 190          
 191          void delay(int ms)
 192          {
 193   1       int index1 = 0;
 194   1       int index2 = 0;
 195   1      
 196   1        for (index1 = 0; index1 <= (ms * 2); index1++)
 197   1        {
 198   2          for (index2 = 0; index2 <= 1000; index2++)
 199   2          { }
 200   2        }
 201   1      }
 202          
 203          
 204          int potenzieren(int basis, int potenz)
 205          {
 206   1        // init index
 207   1        int positivePotenz = potenz;
 208   1        int index = 0;
 209   1        int zwischenergebnis = 1;
 210   1      
 211   1        if (potenz < 0) {
 212   2          positivePotenz = potenz * (-1);
 213   2        }
 214   1        
 215   1        // die Potenz in einer for-Schleife berechnen
 216   1        for (index = 0; index < positivePotenz; index = index + 1)
 217   1        {
 218   2          // das Zwischenergebnis wird in der Variablen "zwischenergebnis" gespeichert
 219   2          zwischenergebnis = zwischenergebnis * basis;
 220   2        }
 221   1      
 222   1        return zwischenergebnis;
 223   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    838    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      58
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
