C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2021 12:27:21 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************************************************************
   2          h e i n r i c h -h e r t z -b e r u f s k o l l e g  d e r  s t a d t  b o n n
   3          Autor:      Friedjof Noweck
   4          Klasse:     IH119
   5          Datum:      2021-12-08
   6          Datei:      main.c
   7          Einsatz:    Auf dem REG517A Microcontroller
   8          Beschreibung: Lauflicht zweier zusammengeschalteter LED Leisten.
   9          Funktionen:   lässt dieses Lauflicht per Taster kontrollieren.
  10          ******************************************************************************
  11          Aenderungen:
  12          2021-11-08 - Anlegen dieses Projektes
  13          2021-11-23 - Hinzufügen der Funktionalitäten "umdrehen" und "stoppen"
  14          2021-12-02 - Add timer0 and Interrupts
  15          2021-12-08 - Interrupt modification
  16          
  17          *****************************************************************************/
  18          /******************* Text im Quelltext einbinden *********************/
  19          #include "REG517A.h"
  20          
  21          /*************************** Konstanten ******************************/
  22          
  23          
  24          /*********************** globale Variablen ***************************/
  25          int timer0_default = 10;
  26          int timer0_counter = 10;
  27          
  28          /************************** Prototypen *******************************/
  29          void readButton(int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus);
  30          void LEDRunner(int* max_bit_nr, int* direction, int* bit_index, int* port);
  31          void flipDirection(int* direction, int* bit_index, int* max_bit_nr);
  32          void delay(int ms, int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus);
  33          void port_controller(int port, int *port_nr);
  34          int potenzieren(int basis, int potenz);
  35          
  36          // Interrupt functions
  37          void IRQ_Timer0();
  38          
  39          /************************ Hauptprogramm ******************************/
  40          
  41          void main()
  42          {
  43   1        // program vars
  44   1        const int max_bit_nr = 15;
  45   1        int direction = 1;
  46   1        int bit_index = 0;
  47   1        int port = 1;
  48   1        char stop = 0x00;
  49   1        
  50   1        char buttonStatus = 0x00;
  51   1        
  52   1        // Timer 0 Konfigurieren
  53   1        TR0 = 0; // aushalt
  54   1        TF0 = 0; // Überlauf zurücksetzen
  55   1        IT0 = 0; // IR gelöscht
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2021 12:27:21 PAGE 2   

  56   1      
  57   1        TMOD = 0x01; // Timer 0 16Bit
  58   1        TL0  = 0xAF; // 
  59   1        TH0  = 0x3C; // = 0x3CAF
  60   1        
  61   1        // IR System Configuration
  62   1        ET0 = 1; // IR for Timer 0
  63   1        EAL = 0; // All IRs off
  64   1        
  65   1        // Set ports to zero
  66   1        P1 = 0x00;
  67   1        P4 = 0x00;
  68   1        
  69   1        EAL = 1;
  70   1        while (1)
  71   1        {
  72   2          delay(500, &direction, &stop, &bit_index, &max_bit_nr, &buttonStatus);
  73   2          
  74   2          if (stop == 0x00)
  75   2          {
  76   3            LEDRunner(&max_bit_nr, &direction, &bit_index, &port);
  77   3          }
  78   2          else
  79   2          { }
  80   2        }
  81   1      }
  82          void readButton(int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus)
  83          {
  84   1        char button2 = *buttonStatus & 0x02;
  85   1        // Port 5 wird abgefragt
  86   1        if ((P5 & 0x01) == 0x00 && (*buttonStatus & 0x01) == 0x00)
  87   1        {
  88   2          *buttonStatus = *buttonStatus | 0x01;
  89   2          
  90   2          flipDirection(direction, bit_index, max_bit_nr);
  91   2        }
  92   1        else if ((P5 & 0x01) == 0x01 && (*buttonStatus & 0x01) == 0x01)
  93   1        {
  94   2          *buttonStatus = *buttonStatus & 0x0FE;
  95   2        }
  96   1        // Port 6 wird abgefragt
  97   1        if ((P6 & 0x01) == 0x00 &&  button2 == 0x00)
  98   1        {
  99   2          *buttonStatus = *buttonStatus | 0x02;
 100   2          
 101   2          if (*stop == 1)
 102   2          {
 103   3            *stop = 0x00;
 104   3          }
 105   2          else
 106   2          {
 107   3            *stop = 0x01;
 108   3          }
 109   2        }
 110   1        else if ((P6 & 0x01) == 0x01 && button2 == 0x02)
 111   1        {
 112   2          *buttonStatus = *buttonStatus & 0x0FD;
 113   2        }
 114   1      }
 115          void flipDirection(int* direction, int* bit_index, int* max_bit_nr)
 116          {
 117   1        if (*direction == 0x01)
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2021 12:27:21 PAGE 3   

 118   1        {
 119   2          *direction = 0x00;
 120   2        }
 121   1        else
 122   1        {
 123   2          *direction = 0x01;
 124   2        }
 125   1        
 126   1        *bit_index = (*max_bit_nr - *bit_index) + 1;
 127   1      }
 128          
 129          void LEDRunner(int* max_bit_nr, int* direction, int* bit_index, int* port)
 130          {
 131   1        int index = 0;
 132   1        
 133   1        if (*bit_index <= *max_bit_nr)
 134   1        {
 135   2          if (*direction == 1)
 136   2          {
 137   3            if (*bit_index <= 7)
 138   3            {
 139   4              *port = 1;
 140   4              index = *bit_index;
 141   4            }
 142   3            else
 143   3            {
 144   4              *port = 4;
 145   4              index = 0x07 - (*max_bit_nr - *bit_index);
 146   4            }
 147   3          }
 148   2          else
 149   2          {
 150   3            if (*bit_index <= 7)
 151   3            {
 152   4              *port = 4;
 153   4              index = 0x07 - *bit_index;
 154   4            }
 155   3            else
 156   3            {
 157   4              *port = 1;
 158   4              index = *bit_index - *max_bit_nr;
 159   4            }
 160   3          }
 161   2          // switch LED's
 162   2          port_controller(index, port);
 163   2          
 164   2          // add one to the Bit Index
 165   2          *bit_index += 1;
 166   2        }
 167   1        else
 168   1        {
 169   2          // reset Bit Index
 170   2          *bit_index = 1;
 171   2          
 172   2          if (*direction == 1)
 173   2          {
 174   3            *direction = 0x00;
 175   3          }
 176   2          else
 177   2          {
 178   3            *direction = 0x01;
 179   3          }
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2021 12:27:21 PAGE 4   

 180   2        }
 181   1      }
 182          void port_controller(int port, int *port_nr)
 183          {
 184   1        char portOn = 0x00;
 185   1      
 186   1        // turn all bits off
 187   1        P1 = P1 & 0x00;
 188   1        P4 = P4 & 0x00;
 189   1      
 190   1        if (*port_nr == 1)
 191   1        {
 192   2          // turn bit on
 193   2          portOn = potenzieren(2, port);
 194   2          P1 = P1 | portOn;
 195   2        }
 196   1        else if (*port_nr == 4)
 197   1        {
 198   2          // turn bit on
 199   2          portOn = potenzieren(2, port);
 200   2          P4 = P4 | portOn;
 201   2        }
 202   1        else
 203   1        { }
 204   1      }
 205          int potenzieren(int basis, int potenz)
 206          {
 207   1        // init index
 208   1        int positivePotenz = potenz;
 209   1        int index = 0;
 210   1        int zwischenergebnis = 1;
 211   1      
 212   1        if (potenz < 0) {
 213   2          positivePotenz = potenz * (-1);
 214   2        }
 215   1        
 216   1        // die Potenz in einer for-Schleife berechnen
 217   1        for (index = 0; index < positivePotenz; index = index + 1)
 218   1        {
 219   2          // das Zwischenergebnis wird in der Variablen "zwischenergebnis" gespeichert
 220   2          zwischenergebnis = zwischenergebnis * basis;
 221   2        }
 222   1      
 223   1        return zwischenergebnis;
 224   1      }
 225          
 226          void delay(int ms, int* direction, char* stop, int* bit_index, int* max_bit_nr, char* buttonStatus)
 227          {
 228   1        TL0 = 0xAF; // 
 229   1        TH0 = 0x3C; // = 0x3CAF
 230   1        
 231   1        ET0 = 1;
 232   1        TR0 = 1;
 233   1        
 234   1        timer0_counter = ms / 50;
 235   1        
 236   1        while (timer0_counter > 0)
 237   1        {
 238   2          readButton(direction, stop, bit_index, max_bit_nr, buttonStatus);
 239   2        }
 240   1      }
 241          void IRQ_Timer0() interrupt 1
C51 COMPILER V9.60.0.0   MAIN                                                              12/08/2021 12:27:21 PAGE 5   

 242          {
 243   1        TR0 = 0; // timer0 aushalt
 244   1        TF0 = 0; // Überlauf zurücksetzen
 245   1        
 246   1        if (timer0_counter >= 1)
 247   1        {
 248   2          timer0_counter--;
 249   2        }
 250   1        else
 251   1        {
 252   2          timer0_counter = timer0_default;
 253   2          TL0 = 0xAF; // 
 254   2          TH0 = 0x3C; // = 0x3CAF
 255   2        }
 256   1        ET0 = 0;
 257   1      }
 258          
 259          
 260          
 261          
 262          
 263          
 264          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    978    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      75
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
