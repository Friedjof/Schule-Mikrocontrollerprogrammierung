C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          /*****************************************************************************
   2          h e i n r i c h -h e r t z -b e r u f s k o l l e g  d e r  s t a d t  b o n n
   3          Autor:      Friedjof Noweck
   4          Klasse:     IH119
   5          Datum:      2021-12-10
   6          Datei:      main.c
   7          Einsatz:    
   8          Beschreibung: can conroll the 7 segment display
   9          Funktionen:   display numbers on 7 segment displays
  10          ******************************************************************************
  11          Aenderungen:
  12          2021-12-10 init project + add simple functions
  13          2021-12-14 work on the functions
  14          2022-01-19 migation to the school controller
  15          2022-02-06 Add Timer0 and memory optimization
  16          2022-02-09 Fix edit mode bug
  17          
  18          *****************************************************************************/
  19          /******************* Text im Quelltext einbinden **********************/
  20          #include "REG517A.h"
  21          
  22          /*************************** Konstanten *******************************/
  23          
  24          
  25          /*********************** globale Variablen ****************************/
  26          // Zähler zum Speichern von Zeit; Einheit in ms [max 1000ms]
  27          unsigned char timerCounter = 0;
  28          unsigned int timer = 0;
  29          
  30          int number2display = 0x00;
  31          
  32          /************************** Definitionen ******************************/
  33          // REG517A specific
  34          #define maxNumber 9999
  35          
  36          /************************** Prototypen ********************************/
  37          char readButtonMatrix(char maxRows, char maxColumns);
  38          void display(char number, char segment);
  39          char index2number(char index);
  40          char getNumber(int numbers, char index);
  41          int fixPotenz(char potenz);
  42          void IRQ_Timer0();
  43          // Arduino Mega specific
  44          //ISR(TIMER0_COMPA_vect);
  45          
  46          /*
  47           * Friedjof Noweck
  48           * 2022-01-25 Di
  49           * 
  50           * +-------------------------------------------------------------------+
  51           * | Anleitung:                                                        |
  52           * |  Der Controller starte im Editier-Modus. Erkennbar auch an dem    |
  53           * |  blickenden Cursor. Hier können Zahlen über die Matrixtastatur    |
  54           * |  gesetzt werden. Der Cursor wandert nach rechts weiter.           |
  55           * |  Alternativ kann auch über die Button-Matrix eine exakte Position |
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 2   

  56           * |  festgelegt werden (A 1000er, B 100er, C 10er, D 1er). Auch kann  |
  57           * |  die Zahl in dem Editor Modus per Inkrementalgeber hoch bzw.      |
  58           * |  runtergeregelt werden. Der Cursor wird hierbei nicht beachtet.   |
  59           * |                                                                   |
  60           * |  Durch das Drücken von dem rechten Taster wird der Zähler         |
  61           * |  gestartet. Die Richtung kann auch umgekehrt werden mit dem       |
  62           * |  linken Taster. Durch das erneute Drücken auf den rechten Taster  |
  63           * |  wird der Zähler wieder angehalten und der Editiermodus           |
  64           * |  gestartet. Beim laufenden Zähler ist die Button-Matrix           |
  65           * |  deaktiviert.                                                     |
  66           * |                                                                   |
  67           * |  Die Zählgeschwindigkeit kann geändert werden, indem der          |
  68           * |  Inkrementalgeber beim laufenden Zähler hoch bzw. runtergeregelt  |
  69           * |  wird.                                                            |
  70           * |                                                                   |
  71           * |  >> Aufgrund von Speichermangel deaktiviert <<                    |
  72           * |  Durch das Drücken auf den Inkrementalgeber wird der Timer Modus  |
  73           * |  aktiviert. Dies bedeutet, dass bei dem Wert 0 angehalten wird    |
  74           * |  und das Display aufblickt. Dieser Modus wird deaktiviert, wenn   |
  75           * |  während des Blickens eine der beiden anderen Taster gedrückt     |
  76           * |  wird. Durch erneutes Drücken wird dieser Modus ebenfalls wieder  |
  77           * |  deaktiviert.                                                     |
  78           * +-------------------------------------------------------------------+
  79           * | PINBELEGUNG                                                       |
  80           * +------------------------------+--------------------+---------------+
  81           * | Elemente                     |    Arduino Mega    |    REG517A    |
  82           * |                              |   Ports      Pins  |               |
  83           * +------------------------------+-----------+--------+---------------+
  84           * | ● 4x4 Taster Matrix          |           |        |               |
  85           * |   ⸰ ROWS                     | PORTA.0-3 | D22-25 | P6.4-7        |
  86           * |   ⸰ COLUMNS                  | PORTA.4-7 | D26-29 | P8.0-3        |
  87           * | ● 4x 7 Segment Anzeigen      |           |        |               |
  88           * |   ⸰ Segmente                 | PORTL.0-7 | D42-49 | P4.0-7        |
  89           * |   ⸰ Anzeigen                 | PORTB.0-3 | D50-53 | P6.4-7        |
  90           * | ● 2x Taster                  |           |        |               |
  91           * |   ⸰ Start/Stopp              | PORTG.0   | D41    | P5.0          |
  92           * |   ⸰ Richtungswechsel         | PORTG.1   | D40    | P6.0          |
  93           * | ● Inkrementalgeber           |           |        |               |
  94           * |   ⸰ Taster                   | PORTF.2   | A2     | P3.4          |
  95           * |   ⸰ Inkrementalgeber Takt    | PORTF.0-1 | A0-1   | P3.3&5        |
  96           * +------------------------------+-----------+--------+---------------+
  97           * | Quellen:                                                          |
  98           * | ● Timer beim Arduino                                              |
  99           * |   ⸰ https://www.exp-tech.de/blog/arduino-tutorial-timer           |
 100           * | ● Arduino Mega Ports                                              |
 101           * |   ⸰ https://aws1.discourse-cdn.com/arduino/original/4X/6/f/b/6fb6102c3ff917a32b3fabaa7b01c72fb20891
             -9e.png
 102           * | ● Port Adressierung beim Arduino:                                 |
 103           * |   ⸰ https://hartmut-waller.info/arduinoblog/leds-schalten-port-ddr/
 104           * +-------------------------------------------------------------------+
 105           * 
 106           */
 107          
 108          
 109          // Arduino Mega specific
 110          //void setup()
 111          void main()
 112          {
 113   1          // Konstanten
 114   1          // Die Anzahl an vorliegenden 7-Segment-Anzeigen
 115   1          const char nrOfSegments = 0x04;
 116   1          // Die maximal anzuzeigende Zahl
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 3   

 117   1          // Arduino Mega specific
 118   1          //const short maxNumber = 9999;
 119   1      
 120   1          // Speed - Die Zählgeschwindigkeit in ms
 121   1          char speed = 0x05;
 122   1      
 123   1          // Speicherung des letzten ermittelten Button Matrix Indexes [0 - 16, 0 = nichts gedrückt]
 124   1          char currentButtonState = 0x00;
 125   1      
 126   1          // Speicherung des gerade ermittelten Button Matrix Indexes [0 - 16, 0 = nichts gedrückt]
 127   1          char matrixResult = 0x00;
 128   1      
 129   1          // Speichert den Zeitpunkt der letzten Ermittlung des Button Matrix Indexes in ms
 130   1          unsigned int buttonTimeout = timer;
 131   1      
 132   1          // Display Variables
 133   1          // Speichert den Index der aktuell anzuzeigenden 7-Segment-Anzeige
 134   1          char segmentCounter = 0x00;
 135   1          // Speichert den Zeitpunkt der letzten Aktualisierung des Indexes der aktuell anzuzeigenden 7-Segment-
             -Anzeige in ms
 136   1          unsigned int segmentCounterTimer = timer;
 137   1          // Speichert den aktuellen Zählerwert
 138   1          //int number2display = 0x00;
 139   1          // Speichert den Zeitpunkt der letzten Aktualisierung des Zählerwertes
 140   1          unsigned int counterTimer = timer;
 141   1          // Speichert die Ziffer des aktuellen Segments
 142   1          char number = 0x00;
 143   1          // Speichert die Konfiguration der einzelnen Ziffern auf der 7-Segment-Anzeige (beginnend bei 0x3F = 0
             -)
 144   1          // > So könne einstellige Zahlen einfach der Ziffern Konfiguration der 7-Segment-Anzeigen zugeordnet 
             -werden.
 145   1          // Arduino Mega specific
 146   1          //const unsigned char segments[10] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F};
 147   1      
 148   1          /* REG517A specific
 149   1          * c P f e d g b a | HEX  | Display
 150   1          * ----------------+------+--------
 151   1          * 1 0 1 1 1 0 1 1 | 0xBB |   0
 152   1          * 1 0 0 0 0 0 1 0 | 0x82 |   1
 153   1          * 0 0 0 1 1 1 1 1 | 0x1F |   2
 154   1          * 1 0 0 0 1 1 1 1 | 0x8F |   3
 155   1          * 1 0 1 0 0 1 1 0 | 0xA6 |   4
 156   1          * 1 0 1 0 1 1 0 1 | 0xAD |   5
 157   1          * 1 0 1 1 1 1 0 1 | 0xBD |   6
 158   1          * 1 0 1 0 0 0 1 1 | 0xA3 |   7
 159   1          * 1 0 1 1 1 1 1 1 | 0xBF |   8
 160   1          * 1 0 1 0 1 1 1 1 | 0xAF |   9
 161   1          */
 162   1          const unsigned char segments[10] = {0xBB, 0x82, 0x1F, 0x8F, 0xA6, 0xAD, 0xBD, 0xA3, 0xBF, 0xAF};
 163   1      
 164   1          // Speichert die aktuellen Curor Position ab
 165   1          // > Ab Start liegt der Wert auf der ganz linken 7-Segment-Anzeige.
 166   1          unsigned char cursor = nrOfSegments - 0x01;
 167   1      
 168   1          // Speichert folgende wichtige Werte:
 169   1          // { Timer Mode , IG Button , CIG02 , CIG01 , Richtung , Start/Stop , Richtung Button , Start/Stop But
             -ton }
 170   1          unsigned char specialButtons = 0x43; // 0b00000100;
 171   1          // Dient als temporärer Zwischenspeicher der ermitteten Werte
 172   1          unsigned char specialButtonsResult = 0x00;
 173   1      
 174   1          // Set pin modes
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 4   

 175   1          // 4x4 Button Matrix
 176   1          // > Ersten 4 als 'OUTPUT', letzten 4 als 'INPUT'
 177   1          //DDRA = 0x0F0;
 178   1      
 179   1          // 4x 7 Segment Anzeigen
 180   1          // > Ersten 4 als 'INPUT', letzten 4 als 'OUTPUT'
 181   1          //DDRB = 0x0F;
 182   1          // Segments - Definiert alle Pins des Ports als 'OUTPUT'
 183   1          //DDRL = 0x0FF;
 184   1      
 185   1          // Special Buttons
 186   1          // Setzt die ersten zwei Pins dieses Ports als 'INPUTS', die anderen Pins werden als 'OUTPUT' definier
             -t
 187   1          //DDRG = 0x0FC;
 188   1      
 189   1          // Inkrementalgeber
 190   1          // Setzt die ersten drei Pins dieses Ports als 'INPUTS', die anderen Pins werden als 'OUTPUT' definier
             -t
 191   1          //DDRF = 0x0F8;
 192   1      
 193   1          // Timer Setup
 194   1          // Setzen des CTC Moduses
 195   1          // Arduino Mega specific
 196   1          //TCCR0A = (1 << WGM01);
 197   1          // Setzt den Startwert des Timers
 198   1          // > Durch den Startwert von 0x0F9 beträgt ein Druchlauf genau eine ms
 199   1          // Arduino Mega specific
 200   1          //OCR0A = 0x0F9;
 201   1          
 202   1          // Setzen der Interrupt Anfrage
 203   1          // Arduino Mega specific
 204   1          //TIMSK0 |= (1 << OCIE0A);
 205   1          // Aktiviert den Interrupt
 206   1          // Arduino Mega specific
 207   1          //sei();
 208   1          
 209   1          // Setzen der Skalierung von 1 zu 64
 210   1          // Somit wird ist der Timer 64 so langsam wie standartmäßig vorgegeben
 211   1          // Arduino Mega specific
 212   1          //TCCR0B |= (1 << CS01);
 213   1          // Arduino Mega specific
 214   1          //TCCR0B |= (1 << CS00);
 215   1          
 216   1          // Timer0 konfigurieren
 217   1          // ausgeschaltet
 218   1          TR0 = 0;
 219   1          // Überlauf zurückgesetzt
 220   1          TF0 = 0;
 221   1          // IR gelöscht
 222   1          IT0 = 0;
 223   1          // Timer1: Timer, 8bit prescale, Timer0: Timer, 16bit
 224   1          TMOD = 0x01;
 225   1          // Startwert 55535 -> 0x0FC17
 226   1          // 1000 = 1ms
 227   1          //TL0 = 0x017;
 228   1          //TH0 = 0x0FC;
 229   1          TL0 = 0x0EF;
 230   1          TH0 = 0x0D8;
 231   1          
 232   1          // IR System konfigurieren
 233   1          // IR für Timer0 aktiv
 234   1          ET0 = 1;
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 5   

 235   1          // Alles aus
 236   1          EAL = 0;
 237   1          
 238   1          // Interrupts aktivieren
 239   1          EAL = 1;
 240   1          // Timer0 aktiv
 241   1          TR0 = 1;
 242   1      
 243   1          while (1)
 244   1          {
 245   2              // Wenn die vergangene Zeit seit der letzten Abfrage der seperaten Taster, sowie der Button Matrix
             - größer 50ms:
 246   2              if (timer - buttonTimeout > 5)
 247   2              {
 248   3                  // Wenn Zähler nicht aktiv:
 249   3                  if (!((specialButtons & 0x04) >> 0x02))
 250   3                  {
 251   4                      // Matrix abfragen
 252   4                      matrixResult = readButtonMatrix(4, 4);
 253   4                  }
 254   3                  else
 255   3                  { }
 256   3                  
 257   3                  // Zum Abfragen der Taster an Port 5.0 und 6.0 werden diese zunächst auf 1 gesetzt.
 258   3                  P6 = P6 | 0x03;
 259   3                  
 260   3                  // Abfrage der beiden seperaten Taster
 261   3                  // Arduino Mega specific
 262   3                  //specialButtonsResult = PING & 0x03;
 263   3                  specialButtonsResult = (P5 & 0x01) | ((P6 & 0x01) << 0x01); //((P3 & 0x04) >> 0x01);
 264   3      
 265   3                  // Wenn sich der rechte Taster verändert hat:
 266   3                  if ((specialButtons & 0x01) ^ (specialButtonsResult & 0x01))
 267   3                  {
 268   4                          // Aktualisiere das gespeichert Bit
 269   4                          specialButtons = (specialButtons & (0x0FE | (specialButtonsResult & 0x01))) | (0x01 & 
             -(specialButtonsResult & 0x01));
 270   4      
 271   4                          // Wenn ansteigende Flanke:
 272   4                          if (!(specialButtons & 0x01))
 273   4                          {
 274   5                                  // Drehe das stop/start Bit um
 275   5                                  specialButtons = 0x04 ^ specialButtons; //(specialButtons & (0x0FB | (0x04 ^ (
             -specialButtons & 0x04)))) | (0x04 & (0x04 ^ (specialButtons & 0x04)));
 276   5      
 277   5                                  // Setze der Cursor ab die ganz linke Position
 278   5                                  cursor = nrOfSegments - 0x01;
 279   5      
 280   5                                  // Wenn Timer Mode an ist und der wert auf dem Display 0 ist (kurz: wenn das D
             -isplay Blickt):
 281   5                                  if ((specialButtons & 0x80) >> 0x07 && number2display == 0)
 282   5                                  {
 283   6                                      // Timer Modus Bit löschen
 284   6                                      specialButtons = specialButtons & 0x7F;
 285   6                                  }
 286   5                                  else
 287   5                                  { }
 288   5                          }
 289   4                          else
 290   4                          { }
 291   4                  }
 292   3                  else
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 6   

 293   3                  { }
 294   3      
 295   3                  // Wenn sich etwas am linken Taster verändert hat:
 296   3                  if (((specialButtons & 0x02) >> 0x01) ^ ((specialButtonsResult & 0x02) >> 0x01))
 297   3                  {
 298   4                          // Aktualisiere das gespeichter Bit
 299   4                          specialButtons = (specialButtons & (0x0FD | (specialButtonsResult & 0x02))) | (0x02 & 
             -(specialButtonsResult & 0x02));
 300   4      
 301   4                          // Wenn ansteigende Flanke:
 302   4                          if (!(specialButtons & 0x02))
 303   4                          {
 304   5                                  // Drehe das richtungs Bit um
 305   5                                  //specialButtons = (specialButtons & (0x0F7 | (0x08 ^ (specialButtons & 0x08))
             -)) | (0x08 & (0x08 ^ (specialButtons & 0x08)));
 306   5                                  specialButtons = 0x08 ^ specialButtons;
 307   5                                  // Wenn Timer Mode an ist und der wert auf dem Display 0 ist (kurz: wenn das D
             -isplay Blickt):
 308   5                                  if ((specialButtons & 0x80) >> 0x07 && number2display == 0)
 309   5                                  {
 310   6                                      // Timer Modus Bit löschen
 311   6                                      specialButtons = specialButtons & 0x7F;
 312   6                                  }
 313   5                                  else
 314   5                                  { }
 315   5                          }
 316   4                          else
 317   4                          { }
 318   4                  }
 319   3                  else
 320   3                  { }
 321   3      
 322   3                  // Wenn ein Taster der Matrix Tastatur gedrückt wurde und sich der Zustand geändert hat:
 323   3                  if (matrixResult && (currentButtonState ^ matrixResult))
 324   3                  {
 325   4                      // Neuen Matrix-Tastatur-Status setzen 
 326   4                      currentButtonState = matrixResult;
 327   4      
 328   4                      // Versetzen des Cursors
 329   4                      // Wenn A gedrückt:
 330   4                      if (currentButtonState == 0x01)
 331   4                      {
 332   5                          // Setze Cursor auf 1000er Stelle
 333   5                          cursor = nrOfSegments - 0x04;
 334   5                      }
 335   4                      // Sonst wenn B gedrückt:
 336   4                      else if (currentButtonState == 0x05)
 337   4                      {
 338   5                          // Setze Cursor auf 100er Stelle
 339   5                          cursor = nrOfSegments - 0x03;
 340   5                      }
 341   4                      // Sonst wenn C gedrückt:
 342   4                      else if (currentButtonState == 0x09)
 343   4                      {
 344   5                          // Setze Cursor auf 10er Stelle
 345   5                          cursor = nrOfSegments - 0x02;
 346   5                      }
 347   4                      // Sonst wenn D gedrückt:
 348   4                      else if (currentButtonState == 0x0D)
 349   4                      {
 350   5                          // Setze Cursor auf 1er Stelle
 351   5                          cursor = nrOfSegments - 0x01;
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 7   

 352   5                      }
 353   4                      // Sonst wenn * gedrückt:
 354   4                      else if (currentButtonState == 0x04)
 355   4                      { }
 356   4                      // Sonst wenn # gedrückt:
 357   4                      else if (currentButtonState == 0x02)
 358   4                      { }
 359   4                      // Andernfalls bei einer anderen Taste:
 360   4                      else
 361   4                      {
 362   5                          // Ziehe die Zahl des Cursor von der angezeigten Zahl ab
 363   5                          number2display -= getNumber(number2display, cursor + 0x01) * fixPotenz(cursor);
 364   5                          // Füge die gedrückte Zahl auf der Matrix Tastatur an die Stelle des Cursors ein 
 365   5                          number2display += index2number(currentButtonState) * fixPotenz(cursor);
 366   5      
 367   5                          // Wenn der Cursor größer ist als 0:
 368   5                          if (cursor > 0x00)
 369   5                          {
 370   6                              // Versetze den Cursor einen weiter nch rechts
 371   6                              cursor--;
 372   6                          }
 373   5                          else
 374   5                          {
 375   6                              // Sonst setze den Cursor wieder nach ganz links
 376   6                              cursor = nrOfSegments - 0x01;
 377   6                          }
 378   5                      }
 379   4                  }
 380   3                  // Sonst, wenn keine Taste gedückt, allerdings noch ein anderer Wert außer 0 gespeichert ist
             - (kurz: Bei einer fallende Flanke):
 381   3                  else if (!matrixResult && currentButtonState)
 382   3                  {
 383   4                      // Setze den gespeicherten Wert zurück. 
 384   4                      currentButtonState = 0x00;
 385   4                  }
 386   3                  else
 387   3                  { }
 388   3      
 389   3                  // Die Zeit seit dem letzten mal Drücken wird auf "jetzt" gesetzt (aktualisiert)
 390   3                  buttonTimeout = timer;
 391   3              }
 392   2              else
 393   2              { }
 394   2      
 395   2              // Inkrementalgeber auslesen
 396   2              // Der Port des Inkrementalgebers wird abgefragt
 397   2              // Arduino Mega specific
 398   2              //specialButtonsResult = PINF & 0x07;
 399   2              specialButtonsResult = ((P3 & 0x18) >> 0x02) | ((P3 & 0x20) >> 0x05);
 400   2              
 401   2              //specialButtonsResult = ((P3 & 0x08) >> 0x02) | ((P3 & 0x20) >> 0x05);
 402   2      
 403   2              // Inkrementalgeber Button
 404   2              // Wenn sich der gespeicherte und der gerade abgefragte Zustand unterscheiden:
 405   2              if ((specialButtonsResult & 0x04) ^ ((specialButtons & 0x40) >> 0x04))
 406   2              {
 407   3                  // Wenn das Bit für den Inkrementalgeber Button gesetzt ist:
 408   3                  if (specialButtonsResult & 0x04)
 409   3                  {
 410   4                      // Wenn der Timer Modus aktiviert ist und der aktuelle Zählerwert bei 0 liegt (kurz: Wenn
             - das Display blickt):
 411   4                      if (((specialButtons & 0x80) >> 0x07) && !number2display)
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 8   

 412   4                      {
 413   5                          // Setze das Bit für den Richtungs Button auf 1
 414   5                          specialButtons = specialButtons | 0x04;
 415   5                      }
 416   4                      else
 417   4                      { }
 418   4      
 419   4                      // Drehe das Richtungs-Bit um
 420   4                      specialButtons = 0x80 ^ specialButtons; // (specialButtons & (0x7F | (0x80 ^ (specialButto
             -ns & 0x80)))) | (0x80 & (0x80 ^ (specialButtons & 0x80)));
 421   4                  }
 422   3                  else
 423   3                  { }
 424   3      
 425   3                  // Speichere den aktuellen Wert des Inkrementalgeber Tasters ab
 426   3                  specialButtons = (specialButtons & (0xBF | ((specialButtonsResult & 0x04) << 0x04))) | (0x40 &
             - ((specialButtonsResult & 0x04) << 0x04));
 427   3              }
 428   2              else
 429   2              { }
 430   2      
 431   2              // Wenn die gespeichten Werte des Inkrementalgebers von den aktuell gemessenen unterscheiden:
 432   2              if (((specialButtonsResult & 0x03) ^ ((specialButtons & 0x30) >> 0x04)))
 433   2              {
 434   3                  // Wenn beide gespeicherten Werte auf 1 stehen:
 435   3                  if ((specialButtons & 0x30) / 0x30)
 436   3                  {
 437   4                      // Wenn das erste aktuelle Bit 1 und das zweite aktuelle Bit 0 ist  (bzw. nach rechts gedr
             -eht wird):
 438   4                      if ((specialButtonsResult & 0x01) && !((specialButtonsResult & 0x02) >> 0x01))
 439   4                      {
 440   5                          // Wenn der Zähler aktuell läuft ist:
 441   5                          if ((specialButtons & 0x04) >> 0x02)
 442   5                          {
 443   6                              // Wenn die Zähl-Gewindigkeit aktuell kleiner oder gleich 64ms ist:
 444   6                              if ((speed * 2) <= 0x64)
 445   6                              {
 446   7                                  // Setze die Zähl-Gewindigkeit auf das doppelte der aktuellen Geschwindigkeit
 447   7                                  speed++;
 448   7                              }
 449   6                              else
 450   6                              { }
 451   6                          }
 452   5                          // Sonst, wenn der Zähler gestoppt ist (bzw. der Editor-Modus aktiv ist):
 453   5                          else
 454   5                          {
 455   6                              // Wenn der aktuelle Zählwert plus 10 nicht den maximalen Zählerwert überschrei
             -tet:
 456   6                              if (number2display < maxNumber)
 457   6                              {
 458   7                                  // Addiere 10 auf den aktuelle Zählerwert drauf
 459   7                                  number2display++;
 460   7                              }
 461   6                              // Sonst, wenn aktuelle Zählwert plus 10 den maximalen Zählerwert überschreitet
             -:
 462   6                              else
 463   6                              {
 464   7                                  // Setze den Zählerwert wieder auf 0 zurück
 465   7                                  number2display = 0x00;
 466   7                              }   
 467   6                          }
 468   5                      }
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 9   

 469   4                      // Sonst, wenn das erste aktuelle Bit 0 und das zweite aktuelle Bit 1 ist (bzw. nach links
             - gedreht wird):
 470   4                      else if (!(specialButtonsResult & 0x01) && ((specialButtonsResult & 0x02) >> 0x01))
 471   4                      {
 472   5                          // Wenn der Zähler aktiv ist:
 473   5                          if ((specialButtons & 0x04) >> 0x02)
 474   5                          {
 475   6                              // Wenn die aktuelle Zählgeschwindigkeit größer ist als 1ms:
 476   6                              if (speed > 0x01)
 477   6                              {
 478   7                                  // Halbiere die aktuelle Zählgeschwindigkeit
 479   7                                  speed--;
 480   7                              }
 481   6                              else
 482   6                              { }
 483   6                          }
 484   5                          // Sonst, wenn der Zähler aktuell gestoppt ist (bzw. der Editor Modus aktiv ist):
 485   5                          else
 486   5                          {
 487   6                              // Wenn die aktuell angezeigte Zahl minus 10 die Grenze von 0 nicht unterschreitet
             -:
 488   6                              if (number2display > 0x00)
 489   6                              {
 490   7                                  // Ziehe von der aktuell angezeigten Zahl 10 ab
 491   7                                  number2display--;
 492   7                              }
 493   6                              // Andernfalls, wenn die aktuell angezeigte Zahl minus 10 die Grenze von 0 untersc
             -hreitet:
 494   6                              else
 495   6                              {
 496   7                                  // Setze den Zähler auf die maximale Zahl hoch
 497   7                                  number2display = maxNumber;
 498   7                              }
 499   6                          }
 500   5                      }
 501   4                      else
 502   4                      { }
 503   4                  }
 504   3                  else
 505   3                  { }
 506   3      
 507   3                  // Setze den gespeicherten Wert des Inkrementalgebers auf den gerade gemessenen Wert
 508   3                  specialButtons = (specialButtons & (0xCF | ((specialButtonsResult & 0x03) << 0x04))) | (0x30 &
             - ((specialButtonsResult & 0x03) << 0x04));
 509   3              }
 510   2              else
 511   2              { }
 512   2              
 513   2              // Display
 514   2              // Extrahiert die Zahl des aktuellen Segments aus der gesamten Zahl und speichert diesen in der Va
             -riablen 'number'
 515   2              // Bsp.: number2display = 9876, segmentCounter + 0x01 = 0x02, return => 7
 516   2              number = getNumber(number2display, segmentCounter + 0x01);
 517   2      
 518   2              // Wenn der Timer Modus aktiv ist und der Zählerwert 0 ist:
 519   2              if (((specialButtons & 0x80) >> 0x07) && !number2display)
 520   2              {
 521   3                  // Wenn der Timer größer oder gleich 500ms ist:
 522   3                  if ((timer % 20) < 10)
 523   3                  {
 524   4                      // Zeige die Nummer des aktuellen Segments an
 525   4                      //display(segments[(int)number], (nrOfSegments - 0x01) - segmentCounter);
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 10  

 526   4                      display(segments[(int)number], segmentCounter);
 527   4                  }
 528   3                  // Sonst, wenn der Timer kleiner als 500ms ist:
 529   3                  else
 530   3                  {
 531   4                      // Zeige nichts auf dem aktuellen Segment an
 532   4                      //display(0x00, (nrOfSegments - 0x01) - segmentCounter);
 533   4                      display(0x00, segmentCounter);
 534   4                  }
 535   3              }
 536   2              // Sonst, wenn der Timer Modus nicht aktiv ist und der Zählerwert nicht 0 ist:
 537   2              else
 538   2              {
 539   3                  // Wenn das aktuelle Segment nicht dem aktuellen Werte des Cursors entspricht oder der Editor 
             -Modus nicht aktiv ist:
 540   3                  if (((specialButtons & 0x04) >> 0x02) || segmentCounter != cursor)
 541   3                  {
 542   4                      // Zeige die aktuelle Ziffer auf dem aktuellen Segment an
 543   4                      //display(segments[(int)number], (nrOfSegments - 0x01) - segmentCounter);
 544   4                      display(segments[(int)number], segmentCounter);
 545   4                  }
 546   3                  // Sonst, wenn der Timer größer oder gleich 500ms ist:
 547   3                  else if ((timer % 20) < 10)
 548   3                  {
 549   4                      // Zeige die aktuelle Ziffer auf dem aktuellen Segment an
 550   4                      // Arduino Mega specific
 551   4                      //display(segments[(int)number], (nrOfSegments - 0x01) - segmentCounter);
 552   4                      display(segments[(int)number], segmentCounter);
 553   4                  }
 554   3                  // Sonst, wenn der Timer kleiner als 500ms ist und wenn das aktuelle Segment nicht dem aktuell
             -en Werte des Cursors entspricht oder der Editor Modus nicht aktiv ist:
 555   3                  else
 556   3                  {
 557   4                      // Zeige nichts auf dem aktuellen Segment an
 558   4                      // Arduino Mega specific
 559   4                      //display(0x00, (nrOfSegments - 0x01) - segmentCounter);
 560   4                      display(0x00, segmentCounter);
 561   4                  }
 562   3              }
 563   2      
 564   2              // Notiz: NUR bei speed = 5 gibt es einen Bug beim Counter?!
 565   2              // TODO: Start/Stop Taster funktionier noch nicht korrekt
 566   2              //       Speziell funktioniert der Editor Modus noch nicht.
 567   2              if (((specialButtons & 0x80) >> 0x07) && number2display == 0x00)
 568   2              {
 569   3                  specialButtons = specialButtons & 0xFB;
 570   3              }
 571   2              else
 572   2              { }
 573   2              
 574   2              // Counter defs
 575   2              // Wenn die Differenz zwischen der aktuelle und dem letzten Zählvorgang größer oder gleich der 
             -Zählgeschwindigkeit und der Timer aktiv ist:
 576   2              if (timer - counterTimer > speed && ((specialButtons & 0x04) >> 0x02))
 577   2              {
 578   3                  // Speicher den Zeitpunkt der aktuellen Aktualisierung des Zählerwertes ab
 579   3                  counterTimer = timer;
 580   3                  
 581   3                  // Wenn der aktuelle Zählerstand der für die Richtung spezifischen Endzahl entspricht:
 582   3                  if (number2display == maxNumber * ((((specialButtons & (0x0F7 | (0x08 ^ (specialButtons & 0x08
             -)))) | (0x08 & (0x08 ^ (specialButtons & 0x08)))) & 0x08) >> 0x03))
 583   3                  //if (number2display)
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 11  

 584   3                  {
 585   4                      // Setze den Zählerwert auf die für die Richtung spezifischen Startwert zurück
 586   4                      number2display = maxNumber * ((specialButtons & 0x08) >> 0x03);
 587   4                  }
 588   3                  // Sonst, wenn der aktuelle Zählerstand der für die Richtung spezifischen Endzahl nicht ents
             -pricht:
 589   3                  else
 590   3                  {
 591   4                      // Addiere auf die aktuell angezeigte Zahl den für die Richtung spezifischen Wert (1 oder
             - -1)
 592   4                      number2display += (1 + ((-2) * ((specialButtons & 0x08) >> 0x03)));
 593   4                  }
 594   3              }
 595   2              else
 596   2              { }
 597   2      
 598   2              // Wenn die Differenz zwischen der letzten Segment-Aktualisierung und der aktuellen Zeit größer 
             -oder gleich 5ms ist:
 599   2              //if (timer - segmentCounterTimer >= 0x01)
 600   2              //{
 601   2              // Wenn das aktuelle Segment nicht das letzte in der Richtung ist:
 602   2              if (segmentCounter < (nrOfSegments - 0x01))
 603   2              {
 604   3                  // Gehe ein Segment weiter
 605   3                  segmentCounter++;
 606   3              }
 607   2              // Sonst, wenn das aktuelle Segment das letzte in der Richtung ist:
 608   2              else
 609   2              {
 610   3                  // Springe auf das erste zurück
 611   3                  segmentCounter = 0x00;
 612   3              }
 613   2              //      // Speicher die Zeit der letzten Segment-Aktualisierung ab
 614   2              //      segmentCounterTimer = timer;
 615   2              //}
 616   2              //else
 617   2              //{ }
 618   2              
 619   2              //if (timer < buttonTimeout)
 620   2              //{
 621   2              //   buttonTimeout = 0x00;
 622   2              //}
 623   2              //else if (timer < segmentCounterTimer)
 624   2              //{
 625   2              //   segmentCounterTimer = 0x00;
 626   2              //}
 627   2              //else if (timer < counterTimer)
 628   2              //{
 629   2              //  counterTimer = 0x00;
 630   2              //}
 631   2      
 632   2              // Wenn der Timer die Zeit von einer Sekunde überschreitet:
 633   2              //if (timer > 0x3e8)
 634   2              //{
 635   2              //    // Setze den Timer, die Zeit seit der letzten Abfrage der seperaten Taster, sowie der Button
             - Matrix und
 636   2              //    // die Zeit seit der letzten Segment-Aktualisierung auf 0 zurück.
 637   2              //    timer = buttonTimeout = segmentCounterTimer = counterTimer = 0;
 638   2              //}
 639   2              //else
 640   2              //{ }
 641   2          }
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 12  

 642   1      }
 643          
 644          //void loop()
 645          //{ }
 646          
 647          
 648          // This is the interrupt request
 649          // Addiere nach 1ms 1 auf den Timer
 650          //ISR(TIMER0_COMPA_vect)
 651          //{
 652          //  timer++;
 653          //}
 654          
 655          void IRQ_Timer0() interrupt 1
 656          {
 657   1          TR0 = 0;
 658   1          EAL = 0;
 659   1      
 660   1          if (timerCounter < 1)
 661   1          {
 662   2              timerCounter++;
 663   2          }
 664   1          else
 665   1          {
 666   2              timerCounter = 0x00;
 667   2              timer++;
 668   2              //number2display++;
 669   2          }
 670   1      
 671   1          //TL0 = 0x017;
 672   1          //TH0 = 0x0FC;
 673   1      
 674   1          TL0 = 0x0EF;
 675   1          TH0 = 0x0D8;
 676   1      
 677   1          EAL = 1;
 678   1          TR0 = 1;
 679   1      }
 680          
 681          // Gibt die Zahl an dem gewünschten Index zurück
 682          // Bsp.: numbers = 1234, index = 4, return => 1
 683          char getNumber(int numbers, char index)
 684          {
 685   1          // Index var
 686   1          char i = 0x00;
 687   1          // Zwischenspeicher
 688   1          char cache = 0;
 689   1      
 690   1          for (i = 0x00; i < index; i++)
 691   1          {
 692   2              // Gibt den Rest zurück
 693   2              cache = numbers % 10;
 694   2      
 695   2              // Teilen durch 10
 696   2              numbers /= 10;
 697   2          }
 698   1      
 699   1          // Rückgabe der gewünschten Zahl
 700   1          return cache;
 701   1      }
 702          
 703          // Ließt die Buttton Matrix aus und gibt den INDEX des gedrückten Tasters zurück
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 13  

 704          char readButtonMatrix(char maxRows, char maxColumns)
 705          {
 706   1          // Zwischenspeicher [LOOPS]
 707   1      
 708   1          char row;
 709   1          char column;
 710   1          
 711   1          // Display ausschalten
 712   1          P4 = 0x00;
 713   1      
 714   1          for (row = 0; row < maxRows; row++)
 715   1          {
 716   2              // Setzen der Ausgänge (aktiver Eingang auf LOW)
 717   2              // 0b1110XXXX > 0b1101XXXX > 0b1011 > 0b0111XXXX
 718   2              //PORTA = 0x0F0 - (0x01 << (row + 0x04));
 719   2              P6 = (P6 & 0x0F) | (0x0F0 ^ (0x10 << row));
 720   2              //P8 = (P8 & 0x0F0) | (0x0F - (0x01 << row));
 721   2      
 722   2              for (column = 0; column < maxColumns; column++)
 723   2              {
 724   3                  // Wenn an einem Eingang 0 anliegt
 725   3                  // Arduino Mega specific
 726   3                  //if (!((PINA & (0x01 << column)) >> column))
 727   3                  if (!((P8 & (0x01 << column)) >> column))
 728   3                  //if (!((P6 & (0x10 << column)) >> (column + 0x04)))
 729   3                  {
 730   4                          // Gebe den Index des gedrückten Buttons zurück (1 - 16)
 731   4                          return (maxColumns * row) + column + 0x01;
 732   4                          //column = column;
 733   4                  }
 734   3                  else
 735   3                  { }
 736   3              }
 737   2          }
 738   1      
 739   1          // Gibt 0x00 zurück, wenn kein Button gedrückt ist.
 740   1          return 0x00;
 741   1      }
 742          
 743          // Löst den Index der Button Matrix zu Ziffern auf
 744          char index2number(char index)
 745          {
 746   1          switch(index)
 747   1          {
 748   2              case 0x03: return 0x00;
 749   2              case 0x06: return 0x09;
 750   2              case 0x07: return 0x08;
 751   2              case 0x08: return 0x07;
 752   2              case 0x0A: return 0x06;
 753   2              case 0x0B: return 0x05;
 754   2              case 0x0C: return 0x04;
 755   2              case 0x0E: return 0x03;
 756   2              case 0x0F: return 0x02;
 757   2              case 0x10: return 0x01;
 758   2              default: return 0x00;
 759   2          }
 760   1      }
 761          
 762          // Setzt die Segment Konfiguration auf das angegebene Segment
 763          void display(char segmentConfiguration, char segment)
 764          {
 765   1          P6 = P6 | 0x0F0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/10/2022 15:37:25 PAGE 14  

 766   1          
 767   1          // Setzen der einzelnen Segmente
 768   1          //PORTL = segmentConfiguration;
 769   1          P4 = segmentConfiguration;
 770   1          
 771   1          // Setzen der Eingänge
 772   1          //PORTB = 0x0F - (0x01 << segment);
 773   1          //P6 = P6 | (0x0F - (0x01 << segment));
 774   1          P6 = (P6 & 0x0F) | (0x0F0 ^ (0x10 << segment));
 775   1      }
 776          
 777          // Gibt die angegebenen Potenz zur Basis 10 zurück
 778          int fixPotenz(char potenz)
 779          {
 780   1          // init index
 781   1          char index = 0x00;
 782   1          int zwischenergebnis = 1;
 783   1      
 784   1          // die Potenz in einer for-Schleife berechnen
 785   1          for (index = 0; index < potenz; index++)
 786   1          {
 787   2              // das Zwischenergebnis wird in der Variablen "zwischenergebnis" gespeichert
 788   2              zwischenergebnis = zwischenergebnis * 10;
 789   2          }
 790   1          return zwischenergebnis;
 791   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1370    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
